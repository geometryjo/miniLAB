<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>miniLAB</title>
  <script src="mathbox-bundle.js"></script>
  <script src="dat.gui.js"></script>
  <script src="parser.js"></script>
  <link rel="stylesheet" href="mathbox.css">
  <link href="https://fonts.googleapis.com/css2?family=Latin+Modern+Roman&display=swap" rel="stylesheet">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/expr-eval@2.0.2/dist/bundle.min.js"></script>
    
    <style>
.dg {
  font-family: "Times New Roman", Times, serif;
  font-size: 14px;
  z-index: 10;
}

.dg.ac {
  position: absolute;
  top: 70px;
  left: 50px;
  z-index: 9999;
}

.mathjax-container {
  font-size: 18px;
  font-weight: bold;
  color: lightgreen;
  padding: 5px;
  cursor: pointer;
}

.mathjax-input {
  width: 100%;
  padding: 10px;
  color: black;
  font-size: 16px;
  margin: 5px 0;
}
   
 .navbar-inverse .dropdown-menu {
    background-color: #222;
  }
  .navbar-inverse .dropdown-menu > li > a {
    color: #090707 !important;
  }
  .navbar-inverse .dropdown-menu > li > a:hover,
  .navbar-inverse .dropdown-menu > li > a:focus {
    background-color: #ee1414 !important;
    color: #0d0505 !important;
  }

  </style>
</head>

<body>

    <nav class="navbar navbar-inverse">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="#">Minimal Surfaces</a>
        </div>
        <ul class="nav navbar-nav">
          <li class="active"><a href="#">Home</a></li>
          <li class="dropdown">
            <a class="dropdown-toggle" data-toggle="dropdown" href="#">Surfaces Library
            <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a href="#">Surfaces Library</a></li>
            </ul>
          </li>
          <li><a href="#">Page 2</a></li>
          <li><a href="#">Page 3</a></li>
        </ul>
      </div>
    </nav>
    
<script>
        

        var mathbox = mathBox({
          plugins: ['core', 'controls', 'cursor', 'mathbox'],
          controls: {klass: THREE.OrbitControls}
        });
        if (mathbox.fallback) throw "WebGL not supported"
    
        var three = mathbox.three;
        three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);
    
        var graphData, view;
        
        var xFunctionText = "1/3*u*(1-u^2+3*v^2)";
        var yFunctionText = "1/3*v*(1-v^2+3*u^2)";
        var zFunctionText = "u^2-v^2";
        
 const surfaceLibrary = {
  "Enneper": {
    x: "1/3*u*(1 - u^2 + 3*v^2)",
    y: "1/3*v*(1 - v^2 + 3*u^2)",
    z: "u^2 - v^2",
    xMin: -3, xMax: 3,
    yMin: -3, yMax: 3,
    zMin: -3, zMax: 3,
    uMin: -2.1, uMax: 2.1,
    vMin: -2.1, vMax: 2.1
  },
  "Catenoid": {
    x: "cos(v) * cosh(u)",
    y: "sin(v) * cosh(u)",
    z: "u",
    xMin: -4, xMax: 4,
    yMin: -4, yMax: 4,
    zMin: -2, zMax: 2,
    uMin: -1.5, uMax: 5,
    vMin: 0, vMax: 5,
  },
  "Helicoid": {
    x: "u * cos(v)",
    y: "u * sin(v)",
    z: "v",
    xMin: -3, xMax: 3,
    yMin: -3, yMax: 3,
    zMin: -6, zMax: 6,
    uMin: -2, uMax: 2,
    vMin: -3, vMax: 5
  },
    "Saddle ridge": {
    x: "u",
    y: "v",
    z: "u^2-v^2",
    xMin: -4, xMax: 4,
    yMin: -4, yMax: 4,
    zMin: -2, zMax: 2,
    uMin: -1.5, uMax: 5,
    vMin: 0, vMax: 5,
  },
  "Ridge": {
    x: "u",
    y: "v",
    z: "u^2",
  },
    "Peak": {
    x: "u",
    y: "v",
    z: "u^2+v^2-sqrt(u^4+v^4)",
  },
    "Plane": {
    x: "u",
    y: "v",
    z: "0",
  },
  "Ridge": {
    x: "u",
    y: "v",
    z: "u^2",
  },
  "Saddle Vally": {
    x: "u",
    y: "v",
    z: "u^2-v^2+0.1*(u^2+v^2)",
  },

  "Valley": {
    x: "u",
    y: "v",
    z: "-u^2",
  },
  "Pit": {
    x: "u",
    y: "v",
    z: "u^2+v^2",
  },







 }





        var params = {
          a: 1,
          b: 0.5,
          meanCurvatureValue: 0,
          gaussianCurvatureValue: 0
          
        };
    
        var xMin = -3, xMax = 3, yMin = -2, yMax = 2, zMin = -3, zMax = 3;
        var uMin = -2.1, uMax = 2.1, vMin = -1.5, vMax = 1.5;

        var meanCurvLastValue = 0;

var surfaceStatus = {
  type: "unknown"
};

var previousSurfaceType = "unknown";

var exportParams = {
  stlResolution: 64  // default resolution
};

           // LaTeX formatting function
    function formatLatex(expression) {
      expression = expression.replace(/sqrt\(([^)]+)\)/g, "\\sqrt{$1}");
      expression = expression.replace(/\^(\w+)/g, "^{$1}");
      expression = expression.replace(/_(\w+)/g, "_{$1}");
      expression = expression.replace(/\bpi\b/g, "\\pi");
      expression = expression.replace(/\be\b/g, "e");
      expression = expression.replace(/\bcos\b/g, "\\cos");
      expression = expression.replace(/\bsin\b/g, "\\sin");
      expression = expression.replace(/\btan\b/g, "\\tan");
      expression = expression.replace(/\bcosec\b/g, "\\cosec");
      expression = expression.replace(/\bsec\b/g, "\\sec");
      expression = expression.replace(/\bcot\b/g, "\\cot");
      expression = expression.replace(/\bln\b/g, "\\ln");
      expression = expression.replace(/\blog\b/g, "\\log");
      expression = expression.replace(/(\d+|\w+)\/(\d+|\w+)/g, "\\frac{$1}{$2}");
      return expression;
    }

    function loadSurfaceFromLibrary(name) {
  const surf = surfaceLibrary[name];
  if (!surf) return;

  xFunctionText = surf.x;
  yFunctionText = surf.y;
  zFunctionText = surf.z;

  // Render MathJax display ใหม่
  updateGraph();
  renderMathJaxAll();
}

function renderMathJaxAll() {
  document.querySelectorAll(".mathjax-container").forEach((el, idx) => {
    let latex = formatLatex(
      idx === 0 ? xFunctionText :
      idx === 1 ? yFunctionText : zFunctionText
    );
    el.innerHTML = `\\( ${latex} \\)`;
  });
  MathJax.typesetPromise();
}



    // Add LaTeX editable fields to the GUI
    function addMathJaxEditable(gui, label, paramKey) {
    let folder1 = gui.addFolder(label);
    

    let container = document.createElement("div");
    container.className = "mathjax-container";

    function renderMathJax() {
        let formattedLatex = formatLatex(window[paramKey]);
        container.innerHTML = `\\( ${formattedLatex} \\)`;
        MathJax.typesetPromise();
    }

    container.onclick = function () {
        let input = document.createElement("input");
        input.type = "text";
        input.value = window[paramKey];
        input.className = "mathjax-input";

        input.onblur = function () {
            window[paramKey] = input.value;
            folder1.__ul.replaceChild(container, input);
            renderMathJax();
            updateGraphFunc(); // Update the graph when the expression changes
        };

        input.onkeypress = function (event) {
            if (event.key === "Enter") {
                window[paramKey] = input.value;
                folder1.__ul.replaceChild(container, input);
                renderMathJax();
                updateGraphFunc(); // Update the graph when the expression changes
            }
        };

        folder1.__ul.replaceChild(input, container);
        input.focus();
    };

    folder1.__ul.appendChild(container); // Correctly append elements inside the folder
    folder1.open(); // Ensure the folder is visible
    renderMathJax()

    return [folder1]; // Return the folder if needed
}


        function partialDerivative(func, variable, epsilon = 1e-5) {
          return function (u, v) {
            if (variable === "u") {
              return (func(u + epsilon, v) - func(u - epsilon, v)) / (2 * epsilon);
            } else if (variable === "v") {
              return (func(u, v + epsilon) - func(u, v - epsilon)) / (2 * epsilon);
            }
          };
        }
    
        function meanCurvature(xFunc, yFunc, zFunc) {
          return function (u, v) {
            // First partial derivatives
            var xu = partialDerivative(xFunc, 'u')(u, v);
            var xv = partialDerivative(xFunc, 'v')(u, v);
            var yu = partialDerivative(yFunc, 'u')(u, v);
            var yv = partialDerivative(yFunc, 'v')(u, v);
            var zu = partialDerivative(zFunc, 'u')(u, v);
            var zv = partialDerivative(zFunc, 'v')(u, v);
    
            // First fundamental form coefficients
            var E = xu * xu + yu * yu + zu * zu;
            var F = xu * xv + yu * yv + zu * zv;
            var G = xv * xv + yv * yv + zv * zv;
    
            // Second partial derivatives
            var xuu = partialDerivative(partialDerivative(xFunc, 'u'), 'u')(u, v);
            var xuv = partialDerivative(partialDerivative(xFunc, 'u'), 'v')(u, v);
            var xvv = partialDerivative(partialDerivative(xFunc, 'v'), 'v')(u, v);
            var yuu = partialDerivative(partialDerivative(yFunc, 'u'), 'u')(u, v);
            var yuv = partialDerivative(partialDerivative(yFunc, 'u'), 'v')(u, v);
            var yvv = partialDerivative(partialDerivative(yFunc, 'v'), 'v')(u, v);
            var zuu = partialDerivative(partialDerivative(zFunc, 'u'), 'u')(u, v);
            var zuv = partialDerivative(partialDerivative(zFunc, 'u'), 'v')(u, v);
            var zvv = partialDerivative(partialDerivative(zFunc, 'v'), 'v')(u, v);
    
            // Normal vector
            var nx = yu * zv - yv * zu;
            var ny = zu * xv - zv * xu;
            var nz = xu * yv - xv * yu;
            var nLength = Math.sqrt(nx * nx + ny * ny + nz * nz);
    
            // Avoid division by zero in normalization
            if (nLength < 1e-10) return 0;
    
            // Normalize the normal vector
            nx /= nLength;
            ny /= nLength;
            nz /= nLength;
    
            // Second fundamental form coefficients
            var L = xuu * nx + yuu * ny + zuu * nz;
            var M = xuv * nx + yuv * ny + zuv * nz;
            var N = xvv * nx + yvv * ny + zvv * nz;
    
            // Mean curvature
            var denominator = (E * G - F * F);
            if (Math.abs(denominator) < 1e-10) return 0;
            var meanCurv = (E * N - 2 * F * M + G * L) / (2 * denominator);
    
            return meanCurv;
          };
        }
    
        function gaussianCurvature(xFunc, yFunc, zFunc) {
          return function (u, v) {
            // First partial derivatives
            var xu = partialDerivative(xFunc, 'u')(u, v);
            var xv = partialDerivative(xFunc, 'v')(u, v);
            var yu = partialDerivative(yFunc, 'u')(u, v);
            var yv = partialDerivative(yFunc, 'v')(u, v);
            var zu = partialDerivative(zFunc, 'u')(u, v);
            var zv = partialDerivative(zFunc, 'v')(u, v);
    
            // First fundamental form coefficients
            var E = xu * xu + yu * yu + zu * zu;
            var F = xu * xv + yu * yv + zu * zv;
            var G = xv * xv + yv * yv + zv * zv;
    
            // Second partial derivatives
            var xuu = partialDerivative(partialDerivative(xFunc, 'u'), 'u')(u, v);
            var xuv = partialDerivative(partialDerivative(xFunc, 'u'), 'v')(u, v);
            var xvv = partialDerivative(partialDerivative(xFunc, 'v'), 'v')(u, v);
            var yuu = partialDerivative(partialDerivative(yFunc, 'u'), 'u')(u, v);
            var yuv = partialDerivative(partialDerivative(yFunc, 'u'), 'v')(u, v);
            var yvv = partialDerivative(partialDerivative(yFunc, 'v'), 'v')(u, v);
            var zuu = partialDerivative(partialDerivative(zFunc, 'u'), 'u')(u, v);
            var zuv = partialDerivative(partialDerivative(zFunc, 'u'), 'v')(u, v);
            var zvv = partialDerivative(partialDerivative(zFunc, 'v'), 'v')(u, v);
    
            // Normal vector
            var nx = yu * zv - yv * zu;
            var ny = zu * xv - zv * xu;
            var nz = xu * yv - xv * yu;
            var nLength = Math.sqrt(nx * nx + ny * ny + nz * nz);
    
            // Avoid division by zero in normalization
            if (nLength < 1e-10) return 0;
    
            // Normalize the normal vector
            nx /= nLength;
            ny /= nLength;
            nz /= nLength;
    
            // Second fundamental form coefficients
            var L = xuu * nx + yuu * ny + zuu * nz;
            var M = xuv * nx + yuv * ny + zuv * nz;
            var N = xvv * nx + yvv * ny + zvv * nz;
    
            // Gaussian curvature
            var denominator = (E * G - F * F);
            if (Math.abs(denominator) < 1e-10) return 0;
            var gaussianCurv = (L * N - M * M) / denominator;
    
            return gaussianCurv;
          };
        }
    
var updateGraphFunc = function() {
  var xFunc = Parser.parse(xFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });
  var yFunc = Parser.parse(yFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });
  var zFunc = Parser.parse(zFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });
  var meanCurvatureFunc = meanCurvature(xFunc, yFunc, zFunc);
  var gaussianCurvatureFunc = gaussianCurvature(xFunc, yFunc, zFunc);

  graphData.set("expr", function(emit, u, v, i, j, t) {
    emit(xFunc(u, v), zFunc(u, v), yFunc(u, v));
  });

  view.set("range", [[xMin, xMax], [yMin, yMax], [zMin, zMax]]);
  domain.set("range", [[uMin, uMax], [vMin, vMax]]);

  //////////////////////////////////////////////////////////////////////////////////

domainColors.set("expr", function(emit, u, v, i, j, t) {
  var H = meanCurvatureFunc(u, v);
  var K = gaussianCurvatureFunc(u, v);
  var lightness = 2;
  
  // คำนวณสีจาก H (Red channel)
  var r = 0;
  if (H > 0.01) r = 1.0;        // H>0 = แดงเต็ม
  else if (H < -0.01) r = 0.5;  // H<0 = แดงครึ่ง
  
  // คำนวณสีจาก K (Blue channel)  
  var b = 0;
  if (K > 0.01) b = 1.0;        // K>0 = น้ำเงินเต็ม
  else if (K < -0.01) b = 0.5;  // K<0 = น้ำเงินครึ่ง
  
  // คำนวณสีจากทั้งคู่ (Green channel)
  var g = 0;
  if (Math.abs(H) < 0.01 && Math.abs(K) < 0.01) g = 1.0; // ทั้งคู่≈0 = เขียว
  
  emit(r, g, b, 1.0);
});

////////////////////////////////////////////////////////////////////////////////////////////
  // ✅ อัปเดตค่าความโค้งตรงจุดกลางพาราเมตริก
  params.meanCurvatureValue = meanCurvatureFunc((uMin + uMax) / 2, (vMin + vMax) / 2);
  params.gaussianCurvatureValue = gaussianCurvatureFunc((uMin + uMax) / 2, (vMin + vMax) / 2);
  meanCurvLastValue = params.meanCurvatureValue;

  // ✅ ต้องอยู่ "ข้างใน" ฟังก์ชันนี้
  let currentType = Math.abs(params.meanCurvatureValue) < 1e-5
    ? "Minimal Surface"
    : "Not Minimal Surface";

  // ✅ อัปเดตเฉพาะเมื่อค่ามีการเปลี่ยนจริง
  if (currentType !== previousSurfaceType) {
    surfaceStatus.type = currentType;
    previousSurfaceType = currentType;
    surfaceTypeController.updateDisplay();  // 💡 สำคัญ: บอก dat.GUI ให้ refresh
  }
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        
        //stl files exporter
        function exportSTL(xFunc, yFunc, zFunc, uRange, vRange, resolution) {
  let stl = 'solid surface\n';

  const uStep = (uRange[1] - uRange[0]) / (resolution - 1);
  const vStep = (vRange[1] - vRange[0]) / (resolution - 1);

  function vertex(u, v) {
    return [xFunc(u, v), yFunc(u, v), zFunc(u, v)];
  }

  for (let i = 0; i < resolution - 1; i++) {
    for (let j = 0; j < resolution - 1; j++) {
      const u0 = uRange[0] + i * uStep;
      const u1 = uRange[0] + (i + 1) * uStep;
      const v0 = vRange[0] + j * vStep;
      const v1 = vRange[0] + (j + 1) * vStep;

      const p00 = vertex(u0, v0);
      const p10 = vertex(u1, v0);
      const p11 = vertex(u1, v1);
      const p01 = vertex(u0, v1);

      // Triangle 1
      stl += facetToSTL(p00, p10, p11);
      // Triangle 2
      stl += facetToSTL(p00, p11, p01);
    }
  }

  stl += 'endsolid surface\n';

  const blob = new Blob([stl], { type: 'text/plain' });
  const link = document.createElement('a');
  link.download = 'surface.stl';
  link.href = URL.createObjectURL(blob);
  link.click();
}

function facetToSTL(p1, p2, p3) {
  const normal = computeNormal(p1, p2, p3);
  return `facet normal ${normal.join(' ')}\n  outer loop\n` +
         `    vertex ${p1.join(' ')}\n    vertex ${p2.join(' ')}\n    vertex ${p3.join(' ')}\n` +
         `  endloop\nendfacet\n`;
}

function computeNormal(p1, p2, p3) {
  const u = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
  const v = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];
  const nx = u[1] * v[2] - u[2] * v[1];
  const ny = u[2] * v[0] - u[0] * v[2];
  const nz = u[0] * v[1] - u[1] * v[0];
  const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
  return [nx / len, ny / len, nz / len];
}

let time = 0;
let uCenter = (uMin + uMax) / 2;
let vCenter = (vMin + vMax) / 2;

mathbox.clock().on('tick', function (dt) {
  time += dt;

  // Animate u and v in a loop
  let u = uCenter + 0.5 * Math.sin(time);
  let v = vCenter + 0.5 * Math.cos(time);

  let x = xFunc(u, v);
  let y = yFunc(u, v);
  let z = zFunc(u, v);

  pointTrail.set("points", [[x, z, y]]);
});

var updateGraph = function() { updateGraphFunc(); };

        

















    
        var camera = mathbox.camera({proxy: true, position: [2, 1, 2]});
    
        view = mathbox.cartesian({
          range: [[xMin, xMax], [yMin, yMax], [zMin, zMax]],
          scale: [2, 1, 2],
        });
    
         var xAxis = view.axis( {axis: 1, width: 8, detail: 40, color:"red"} );
        var xScale = view.scale( {axis: 1, divide: 10, nice:true, zero:true} );
        var xTicks = view.ticks( {width: 5, size: 15, color: "red", zBias:2} );
        var xFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: xScale} );
        var xTicksLabel = view.label( {color: "red", zIndex: 0, offset:[0,-20], points: xScale, text: xFormat} );
      
      var yAxis = view.axis( {axis: 3, width: 8, detail: 40, color:"green"} );
        var yScale = view.scale( {axis: 3, divide: 5, nice:true, zero:false} );
        var yTicks = view.ticks( {width: 5, size: 15, color: "green", zBias:2} );
        var yFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: yScale} );
        var yTicksLabel = view.label( {color: "green", zIndex: 0, offset:[0,0], points: yScale, text: yFormat} );
      
      var zAxis = view.axis( {axis: 2, width: 8, detail: 40, color:"blue"} );
        var zScale = view.scale( {axis: 2, divide: 5, nice:true, zero:false} );
        var zTicks = view.ticks( {width: 5, size: 15, color: "blue", zBias:2} );
        var zFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: zScale} );
        var zTicksLabel = view.label( {color: "blue", zIndex: 0, offset:[0,0], points: zScale, text: zFormat} );
    
        view.grid({axes: [1, 3], width: 2, divideX: 20, divideY: 20, opacity: 0.25});
    
        var domain = mathbox.cartesian({
          range: [[uMin, uMax], [vMin, vMax]]
        });
    
        var resolution = 32;
        graphData = domain.area({
          width: resolution, height: resolution,
          axes: [1, 2],
          channels: 3,
        });
    
        var domainColors = domain.area({
          width: resolution, height: resolution,
          channels: 4,
          items: 1,
        });
    

        view.surface({
          shaded: false,
          points: graphData,
          colors: domainColors,
          color: 0xffffff,
          opacity: 1,
        });

    
        var surfaceViewLine = view.surface({
      points: graphData,
      fill: false, shaded: false, lineX: true, lineY: true,
      color: "black",
       });

       var pointTrail = view.point({
       color: 0xff00ff,
       size: 10
});


///////////////////////////////////////////////////////////////////////////////////////////////
        var gui = new dat.GUI();


        const surfaceNames = Object.keys(surfaceLibrary);
const libraryParams = { selectedSurface: surfaceNames[0] };

gui.add(libraryParams, 'selectedSurface', surfaceNames)
   .name("Surface Library")
   .onChange(loadSurfaceFromLibrary);

        // Add LaTeX editable fields for all three functions
        gui.add(this, 'updateGraph').name("Parametric equation");
        addMathJaxEditable(gui, "x(u,v)", "xFunctionText");
        addMathJaxEditable(gui, "y(u,v)", "yFunctionText");
        addMathJaxEditable(gui, "z(u,v)", "zFunctionText");
        gui.open();

        var f2 = gui.addFolder('Constants');
        f2.add(params, 'a').name('a').min(0).max(2).step(0.01).onChange(updateGraph);
        f2.add(params, 'b').name('b').min(0).max(2).step(0.01).onChange(updateGraph);
        f2.add(params, 'meanCurvatureValue').name('Mean Curvature').listen();
        f2.add(params, 'gaussianCurvatureValue').name('Gaussian Curvature').listen();
        var surfaceTypeController = f2.add(surfaceStatus, 'type').name('Surface Type');
        f2.open();
    
        var f3 = gui.addFolder('u-range');
        f3.add(window, 'uMin').name('uMin').min(-6.282).max(6.282).step(0.1).onChange(updateGraph);
        f3.add(window, 'uMax').name('uMax').min(-6.282).max(6.282).step(0.1).onChange(updateGraph);
        f3.open();
    
        var f4 = gui.addFolder('v-range');
        f4.add(window, 'vMin').name('vMin').min(-6.282).max(6.282).step(0.1).onChange(updateGraph);
        f4.add(window, 'vMax').name('vMax').min(-6.282).max(6.282).step(0.1).onChange(updateGraph);
        
        f4.open();
    
       
        

        var gui2 = new dat.GUI();
        gui2.domElement.style.position = 'absolute';
        gui2.domElement.style.left = '-50px';  // Moves it to the left
        gui2.domElement.style.top = '0px';  // Adjust the vertical position

        gui2.add({ exportSTL: function () {
  try {
    const xFunc = Parser.parse(xFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });
    const yFunc = Parser.parse(yFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });
    const zFunc = Parser.parse(zFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });

    const uRange = [uMin, uMax];
    const vRange = [vMin, vMax];
    const resolution = 64; // ปรับละเอียดตามต้องการ
    
///////////////////////////////////////////////////////////////////////////////////////////////////////////
var fExport = gui.addFolder("Export");

fExport.add(exportParams, 'stlResolution', 10, 200, 1).name("STL Resolution");

fExport.add({ exportSTL: function () {
  const xFunc = Parser.parse(xFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });
  const yFunc = Parser.parse(yFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });
  const zFunc = Parser.parse(zFunctionText).toJSFunction(['u', 'v'], { a: params.a, b: params.b });

  exportSTL(
    xFunc, yFunc, zFunc,
    [uMin, uMax], [vMin, vMax],
    exportParams.stlResolution  // ✅ ใช้ค่าจาก GUI
  );
}}, 'exportSTL').name("💾 Export STL");

fExport.open();

    exportSTL(xFunc, yFunc, zFunc, uRange, vRange, resolution);
  } catch (e) {
    alert("Error exporting STL: " + e.message);
  }
}}, 'exportSTL').name("💾 Export STL");

        var animationParams = {
        isAnimating: false,
        speed: 0.01,
        playU: false,
        playV: false,
        playA: false,
        playB: false,
        toggleU: function() { /* Updated below */ },
        toggleV: function() { /* Updated below */ },
        toggleA: function() { /* Updated below */ },
        toggleB: function() { /* Updated below */ },
};

        var fAnim = gui2.addFolder('Animation');
        fAnim.add(animationParams, 'speed', 0.001, 2, 0.001).name("Speed");

        // Create controllers and store references
        var uController = fAnim.add(animationParams, 'toggleU').name('Parameter U ▶️');
        var vController = fAnim.add(animationParams, 'toggleV').name('Parameter V ▶️');
        var aController = fAnim.add(animationParams, 'toggleA').name('Parameter A ▶️');
        var bController = fAnim.add(animationParams, 'toggleB').name('Parameter B ▶️');

        // Update toggle functions with icon logic
        animationParams.toggleU = function() {
        animationParams.playU = !animationParams.playU;
        uController.name('Parameter U ' + (animationParams.playU ? '⏸️' : '▶️'));
        animate();
};

    animationParams.toggleV = function() {
    animationParams.playV = !animationParams.playV;
    vController.name('Parameter V ' + (animationParams.playV ? '⏸️' : '▶️'));
    animate();
};

animationParams.toggleA = function() {
    animationParams.playA = !animationParams.playA;
    aController.name('Parameter A ' + (animationParams.playA ? '⏸️' : '▶️'));
    animate();
};

animationParams.toggleB = function() {
    animationParams.playB = !animationParams.playB;
    bController.name('Parameter B ' + (animationParams.playB ? '⏸️' : '▶️'));
    animate();
};

fAnim.open();

// Keep the existing animate function unchanged
function animate() {
    if (animationParams.playU || animationParams.playV || animationParams.playA || animationParams.playB) {
        requestAnimationFrame(animate);
    }

    if (animationParams.playU) {
        window.uMin += animationParams.speed;
        window.uMax += animationParams.speed;
    }
    if (animationParams.playV) {
        window.vMin += animationParams.speed;
        window.vMax += animationParams.speed;
    }
    if (animationParams.playA) {
        params.a = Math.min(2, params.a + animationParams.speed);
    }
    if (animationParams.playB) {
        params.b = Math.min(2, params.b + animationParams.speed);
    }

    updateGraph();
}

loadSurfaceFromLibrary("Enneper");

        updateGraph();

 
      </script>
    </body>
    </html>
    

